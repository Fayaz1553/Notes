===============SPRING FRAMEWORK================
Spring is a lightweight and popular open-source Java-based framework developed by Rod Johnson in 2003. It is used to develop enterprise-level applications. It provides support to many other frameworks such as Hibernate, Tapestry, EJB, JSF, Struts, etc, so it is also called a framework of frameworks. It’s an application framework and IOC (Inversion of Control) container for the Java platform. 
The spring contains several modules like;
spring core - Beans, core, context, exp language
spring web - web, servlet, struts etc
spring DAO - ORM, JDBC, Transactions etc
spring AOP - AOP, Aspects etc

POM --> Project Object Model
POJO --> Plain Old Java Object

--> Spring IoC (Inversion of Control) Container is the core of Spring Framework. It creates the objects, configures and assembles their dependencies, manages their entire life cycle. It gets the information about the objects from a configuration file(XML) or Java Code or Java Annotations and Java POJO class. These objects are called Beans. Since the Controlling of Java objects and their lifecycle is not done by the developers, hence the name Inversion Of Control. It uses dependency injection to achieve inversion of control.

The followings are some of the main features of Spring IoC,
Creating Object for us,
Managing our objects,
Helping our application to be configurable,
Managing dependencies

Two types of IoC containers
---------------------------
BeanFactory is the root interface for accessing the Spring container. It provides basic functionalities for managing beans.
On the other hand, the ApplicationContext is a sub-interface of the BeanFactory. Therefore, it extends/offers all the functionalities of BeanFactory.
 - BeanFactory 
	BeanFactory factory = new ClassPathXmlApplicationContext("bean-factory-demo.xml");
 - ApplicationContext 
	ApplicationContext context = new ClassPathXmlApplicationContext("bean-factory-demo.xml");


 --> Dependency Injection is the main functionality provided by Spring IOC(Inversion of Control). The Spring-Core module is responsible for injecting dependencies through either Constructor or Setter methods. The design principle of Inversion of Control emphasizes keeping the Java classes independent of each other and the container frees them from object creation and maintenance. With this we can achieve loose coupling.

Need for Dependency Injection:
Suppose class One needs the object of class Two to instantiate or operate a method, then class One is said to be dependent on class Two. Now though it might appear okay to depend a module on the other but, in the real world, this could lead to a lot of problems, including system failure. Hence such dependencies need to be avoided.
Spring IOC resolves such dependencies with Dependency Injection, which makes the code easier to test and reuse. Loose coupling between classes can be possible by defining interfaces for common functionality and the injector will instantiate the objects of required implementation.

Two types of Spring Dependency Injection
----------------------------------------
1) Setter Dependency Injection (SDI): This is the simpler of the two DI methods. In this, the DI will be injected with the help of setter and/or getter methods. Now to set the DI in the bean, it is done through the bean-configuration file. For this, the property to be set with the SDI is declared under the <property> tag in the bean-config file.
    <bean id="GFG" class="com.geeksforgeeks.org.GFG"> 
	<property name="companyName" value="GeeksForGeeks"></property>  
        <property name="geek"> 
            <ref bean="CsvGFG" /> 	//for reference objects
        </property> 
    </bean> 
---or---
<bean id="beanId" class="BeanClass"> 
  <property name="secondBean" ref="SecondBean"/> 
  <property name="message" value="This is message."/> 
  <property name="name2"> 
    <map> 
	<entry key="key1" value="value1"/> 	     //for Maps
	<entry key ="key2" value-ref="DataSource"/> 
    </map> 
  </property>
  <property name="employees">
    <list>
	<value>"John"</value>		//for collections
	<value>"Max"</value>
	<value>"Sam"</value>
     </list>
   </property>
</bean>
 

2) Constructor Dependency Injection (CDI): In this, the DI will be injected with the help of contructors. Now to set the DI as CDI in bean, it is done through the bean-configuration file For this, the property to be set with the CDI is declared under the <constructor-arg> tag in the bean-config file.
<bean id="beanId" class="BeanClass"> 
  <constructor-arg type="String" value="test"/> 
  <constructor-arg type="int" value="1002"/> 
</bean>
---or----
<bean id="mathCheatObjectValue" class="MathCheat"></bean>

<bean id="student" class="Student">
    <constructor-arg name="id" value="101"/>
    <constructor-arg name="mathCheat" ref="mathCheatObjectValue"/>    //for reference onjects
</bean>

-> The Spring team generally advocates constructor injection, as it lets you implement application components as immutable objects and ensures that required dependencies are not null. The Spring documentation recommends using constructor-based injection for mandatory dependencies, and setter-based injection for optional ones.

key differences between constructor injection and setter injection
-------------------------------------------------------------------
Partial dependency --- can be injected using setter injection but it is not possible by constructor. Suppose there are 3 properties in a class, having 3 arg constructor and setters methods. In such case, if you want to pass information for only one property, it is possible by setter method only.
Overriding --- Setter injection overrides the constructor injection. If we use both constructor and setter injection, IOC container will use the setter injection.
New Instances --- We can easily change the value by setter injection. It doesn't create a new bean instance always like constructor. So setter injection is flexible than constructor injection.

Spring IoC vs Spring DI
-----------------------
- Spring IoC Container is the core of Spring Framework. It creates the objects, configures and assembles their dependencies, manages their entire life cycle.
  Spring Dependency injection is a way to inject the dependency of a framework component by the following ways of spring: Constructor Injection and Setter Injection
- Spring helps in creating objects, managing objects, configurations, etc. because of IoC (Inversion of Control). 
  Spring framework helps in the creation of loosely-coupled applications because of Dependency Injection.
- Spring IoC is achieved through Dependency Injection.	
  Dependency Injection is the method of providing the dependencies and Inversion of Control is the end result of Dependency Injection.


 -> Bean life cycle is managed by the spring container. When we run the program then, first of all, the spring container gets started. After that, the container creates the instance of a bean as per the request, and then dependencies are injected. And finally, the bean is destroyed when the spring container is closed. Therefore, if we want to execute some code on the bean instantiation and just after closing the spring container, then we can write that code inside the custom init() method and the destroy() method.

Bean life cycle:
----------------
Bean life cycle is managed by the spring container. the bean life cycle refers to when & how the bean is instantiated, what action it performs until it lives, and when & how it is destroyed.
container started -> Bean instantiated -> Dependencies injected -> custom init() method -> custom utility methods -> custom destroy() method.
if we want to execute some code on the bean instantiation and just after closing the spring container, then we can write that code inside the custom init() method and the destroy() method.	

bean scopes  -> @Scope is used to specify bean scopes in springboot
-----------
1) Singleton(default) ---> spring container creates only one instance of bean definition per Spring IoC container(shared among all beans of same type) 
	<beans>
  	   < bean id = "hw" class= "bean.HelloWorld" scope = "singleton" />
	</beans>
2) Prototype ---> A new instance will be created for a single bean definition every time a request is made for that bean.
	<beans>
  	   < bean id = "hw" class= "bean.HelloWorld" scope = "prototype" />
	</beans>
3) request ---> A new instance of the bean is created for each HTTP request. The bean instance is available only for the duration of the current HTTP request. But Only valid in the context of a web Application.
4) session ---> This creates a single bean definition to the lifecycle of an HTTP Session. ie; each HTTP session has its own instance of a bean created off. But Only valid in the context of a web Application.
5) global-session --> This creates a single bean instance per global HTTP Session. It is also only valid in the context of a portal Application.


bean configuration(3 ways)
--------------------------
1. XML configuration  ---> ClassPathXmlApplicationContext
	<bean id=" " class=" " scope="sigleton/prototype" autowired="byName/byType etc">	//in case of autowired, no need to mention setter/costructor inj.
		<property name=" " value=" " (or) ref=" " />	//setter injection
		<contructor-arg name=" " value=" " type=" "(or) ref=" " />  //contructor injection
	</bean>
2. Anotation configuration --> @Component for which we want the bean & write component-scan in xml or in java config class --> ClassPathXmlApplicationContext
	@component
	<component-scan> in xml file or java config
	@Autowired	//to inject dependency (to use autowired, bean has to created for that obj in xml or java config or use @component for that class)
	@Primary or @Qualifier(" ") 	//to remove ambiguity if there r multiple implimentations for interface
3. Java configuration --> @Configuration, @Bean --> AnnotationConfigApplicationContext
	@Configuration //config class is created
	@ComponentScan(base-packages=" ")
	@Bean  //no need to create @component for the classes to which bean in created in config class
	@Autowired	//used to inject the object dependency implicitly. It internally uses setter or constructor injection. Autowiring can't be used to inject primitive and string values. It works with reference only.
	@Primary or @Qualifier(" ")


Modes of Autowiring
-------------------
- No -> tells the framework that autowiring is not supposed to be done. It is the default mode used by Spring
- byName -> It uses the name of the bean for injecting dependencies
- byType -> It injects the dependency according to the type of the bean. It looks up in the configuration file for the class type of the property. If it finds a bean that matches, it injects the property. If not, the program throws an error.
- constructor -> It injects the required dependencies by invoking the constructor. It works similar to the “byType” mode but it looks for the class type of the constructor arguments. If none or more than one bean are detected, then it throws an error
- autoDetect -> uses two other modes for autowiring – constructor and byType. It first tries to autowire via the constructor mode and if it fails, it uses the byType mode for autowiring.






===============SPRING BOOT================
Spring Boot is an open-source Java framework that makes developing web applications and microservices faster and easier. It is a combination of Spring Framework and Embedded Servers. The main goal of Spring Boot is to reduce development, unit test, and integration test time. The spring boot follows a layered architecture in which each layer communicates to other layers. With Spring Boot, you can concentrate on business aspects rather than infrastructure.
Spring Boot Advantages;
	It Create stand-alone Spring applications
	It also minimizes writing multiple boilerplate codes, XML configuration, and annotations (There is no need for XML configuration.)
	It easily tests web applications using several Embedded HTTP servers like as Tomcat, Jetty etc.
	It Provides ‘starter’ dependencies to simplify the build configuration.
	It includes features that are ready for production such as metrics, health checks and externalised settings.

-> Spring Initializer is a Web-based tool that generates the Spring Boot project structure.
-> To remove default embeded server in springBoot, excule the tomcat dependency from spring-boot-starter-web, and add required server dependency in pom.xml

The spring boot consists of the following four layers:
------------------------------------------------------
1.Presentation Layer – Authentication & JSON translation (converting the JSON field’s parameter to Java Objects and vice-versa)
2.Business Layer – contains all the business logic. It is responsible for validation and authorization.
3.Persistence Layer – contains all the database storage logic. It is responsible for converting business objects to the database row and vice-versa.
4.Database Layer – Actual Database. It is responsible for performing the CRUD operations.

FLOW:
Client--->Controller<--->Service lyr<--->Dao lyr<--->DB
  |		|
  <--Jsp pages<--

Service layer: Service layers are meant to implement business logics. ...
Repository/DAO layer: DAO stands for Data Access Object, The main goal of this layer is access(Query) data efficiently from database and provide services to the Service layer.

application.properties
----------------------
server.pot=8585  //The default port of the Tomcat server is 8080
coach.name=Fayaz
team.name=MI
management.endpoints.web.exposure.include=* 	//expose all acutator endpoints over HTTP

-----inside RestController----
@Value("${coach.name}")
private String Coach;

@Value("${team.name}")
private String Team;

Query parameters are appended to the end of the request URL, following ? and listed in key value pairs, separated by &
	•  syntax:  uri?id=1&type=new
Path parameters form part of the request URL, and are referenced using placeholders preceded by : 
	•  syntax:  /customer/:id


Springboot - starters
---------------------
spring-boot-starter -> It is used for core starter, including auto-configuration support, logging, and YAML.
spring-boot-starter-web	-> Starter for building web, including RESTful, applications using Spring MVC. Uses Tomcat as the default embedded container.
spring-boot-starter-data-rest -> It is used for exposing Spring Data repositories over REST using Spring Data REST.
spring-boot-starter-actuator -> It is used for Spring Boot's Actuator that provides production-ready features to help you monitor and manage your application. (The default endpoint is ‘localhost:8080/actuator’. Also /health & /info are available by default prefixed by /acutator)
spring-boot-starter-test -> It is used to test Spring Boot applications with libraries, including JUnit, Hamcrest, and Mockito.
spring-boot-starter-jdbc -> It is used for JDBC with the Tomcat JDBC connection pool.
spring-boot-starter-validation -> It is used for Java Bean Validation with Hibernate Validator.
spring-boot-starter-jersey -> It is used to build RESTful web applications using JAX-RS and Jersey. An alternative to spring-boot-starter-web.
spring-boot-starter-aop -> It is used for aspect-oriented programming with Spring AOP and AspectJ.
spring-boot-starter-amqp -> It is used for Spring AMQP and Rabbit MQ.
spring-boot-starter-security -> It is used for Spring Security.
spring-boot-starter-data-jpa -> It is used for Spring Data JPA with Hibernate.
spring-boot-starter-cache -> It is used for Spring Framework's caching support.
spring-boot-starter-cloud-connectors -> It is used for Spring Cloud Connectors that simplifies connecting to services in cloud platforms like Cloud Foundry and Heroku.
spring-boot-starter-jetty -> It is used for Jetty as the embedded servlet container. An alternative to spring-boot-starter-tomcat.
spring-boot-starter-logging -> It is used for logging using Logback. Default logging starter.
spring-boot-starter-tomcat -> It is used for Tomcat as the embedded servlet container. Default servlet container starter used by spring-boot-starter-web.
spring-boot-starter-log4j2 -> It is used for Log4j2 for logging. An alternative to spring-boot-starter-logging.


spring-boot-devtools //used to automatically reload our appllication whenever code is updated
h2 // it is an open-source lightweight Java database.
Lombok dependency  //it is used to reduce boilerplate code for model/data objects. like @Data annotation is a shortcut annotation and bundles @ToString, @Getter, @Setter, @EqualsAndHashCode and @RequiredArgsConstructor annotations into a single annotation to reduce boilerplate code. @NoArgsConstructor annotation is used to generate a constructor with no arguments. @AllArgsConstructor annotation is used to generate a parameterized constructor which accepts a single parameter for each field and initializes them using it.


Annotations
-----------
@Autowired -> It injects object dependency implicitly. We use @Autowired to mark the dependency that will be injected by the Spring container. It is applied to the fields, setter methods, and constructors. It internally uses setter or constructor injection. Autowiring can't be used to inject primitive and string values.
@Scope -> to define bean scopes. Ex: @Scope("protoype"). Default scope is "singleton" in spring
@SpringBootApplication -> It is used to mark the main class of a Spring Boot application. It is the combination of  @Configuration, @EnableAutoConfiguration and @ComponentScan annotations.
@EnableAutoConfiguration -> is used to enable the auto-configuration feature. It automatically registers the beans with @Component, @Configuration, @Bean that are present in the classpath.
@Controller -> it indicates that they’re front controllers and responsible to handle user requests and return the appropriate response. It is typically used in combination with annotated handler methods based on the @RequestMapping annotation. It can be applied to classes only. It’s used to mark a class as a web request handler
@RestController -> specifies that this class is a controller for RESTful API requests. It is a specialized version of the controller. It includes the @Controller and @ResponseBody annotations. This annotation is used at the class level and allows the class to handle the requests made by the client.
@RequestMapping ->It is used to map requests to controllers methods. It has various attributes to match by URL, HTTP method, request parameters etc.
@Service -> to indicate that they’re holding the business logic(service layer). Spring will create an instance of it automatically.
@Repository -> to indicate that they’re dealing with DB(CRUD) operations, usually, it’s used with DAO (Data Access Object) or Repository implementations that deal with database tables. Spring will create an instance of it automatically. 
@Configuration -> indicates that the class has @Bean definition methods. So Spring container can process the class and generate Spring Beans to be used in the application.
@Bean -> is applied on a method to specify that it returns a bean to be managed by Spring context. Spring Bean annotation is usually declared in Configuration class methods. Whenever you are using the @Bean annotation to create the bean you don’t need to use the @ComponentScan annotation inside your configuration class.
@ComponentScan -> It's used for auto-detecting and registering Spring-managed components (e.g. beans, controllers, services, repositories, etc.) within a specified package or set of packages. It is used along with the @Configuration annotation. It starts scanning from the specified package, which we can define using basePackageClasses() or basePackages(). If no package is specified, then it considers the package of the class declaring the @ComponentScan annotation.
@Component -> it is a class-level annotation. It is used to denote a class as a Component(bean). We can use @Component across the application to mark the beans as Spring managed components
@Primary -> it indicates that a particular bean should be given preference when multiple beans are candidates to be autowired to a single-valued dependency.  
@Qualifier ->  it indicates that, specific bean should be autowired when there are multiple candidates. its used to resolve the autowiring conflict when there are multiple beans of the same type. It can be used on any class annotated with @Component, @Service etc or on methods annotated with @Bean.
@Value -> We can read spring environment variables as well as system variables using this annotation. is used to assign default values to variables and method arguments. 
@PostConstruct -> it gets executed after the spring bean is initialized. We can have only one method annotated with this  annotation.
@PreDestroy -> it gets called when the bean instance is getting removed from the context. Remember that if your spring bean scope is “prototype” then it’s not completely managed by the spring container and the PreDestroy method won’t get called.
@Required -> is a method-level annotation used in the setter method of a bean property and therefore making the setter-injection compulsory. This annotation suggests that the required bean property must be injected with a value at the configuration time & shouldn't be null.
@PathVariable -> it extract values from the URI path & assign to a variable
@RequestParams -> It extract values from the query string & assign to a variable (Qury params -> ?id=abc)
@RequestBody -> takes Json data/HttpRequest body from client and assigns it to respective Object by deserialization.
@ResponseBody -> tells a controller that the object returned is automatically serialized into JSON and passed back into the HttpResponse object.
@EnableScheduling -> It facilitates Spring Boot with scheduled task execution capability
@Scheduled  -> for scheduling a task 
@ExceptionHandler -> to handle exceptions thrown by a specific controller method. Its a method-level  annotation used to provide customized error responses for specific exceptions.
@ControllerAdvice (AOP) -> It is used to define a class that will be called whenever an exception is thrown in your application. This class can contain multiple methods, each of which is annotated with the @ExceptionHandler annotation and is responsible for handling a specific exception.  //for global exception handling
@Entity -> specifies that this class is an entity and should be mapped to a database table.
@Table -> specifies the name of the database table that will store instances of this entity.
@Id -> specifies a field in a model class as the primary key
@GeneratedValue -> specifies that the primary key should be generated automatically based on given strategy.
@Column -> represents a column

@Qualifier vs @Primary
----------------------
there may be scenarios where multiple beans of the same type exist, leading to ambiguity during autowiring. This is where the @Qualifier and @Primary annotations come to our rescue.
@Primary -> used to specify which bean is given higher preference when multiple beans of the same type exist. But it does not allow you to select a specific bean.
@Qualifier -> used to specify which exact bean should be wired where there are multiple beans of the same type. We can also use the @Qualifier with @Component/ @Bean to assign an extra name to the bean.

@Component
@Primary
class TwoWheeler implements Vehicle {}

@Component
class ThreeWheeler implements Vehicle {}

@Component
@Qualifier("FourWheelerQualifier")
class FourWheeler implements Vehicle {}

@Component
class Bike {
    @Autowired  // Bean TwoWheeler will be autowired, becoz it is @Primary
    private Vehicle vehicle;
}

@Component
class Car {
    @Autowired  // Bean FourWheeler will be autowired, becoz we explicitly mentioned which bean we want.
    @Qualifier("FourWheelerQualifier")
    private Vehicle vehicle;
}
Note: @Qualifier has higher priority than @Primary annotation, if used together.


Spring data rest ----> no need of controller and services //search for more info 
	 Spring Data REST is built on top of the Spring Data project and makes it easy to build hypermedia-driven REST web services that connect to Spring Data repositories – all using HAL as the driving hypermedia type. It takes away a lot of the manual work usually associated with such tasks and makes implementing basic CRUD functionality for web applications quite simple.
Spring Data JDBC ----> Spring Data JDBC is a POJO class. @Table, @ID, and @Column annotations are helpful to mention for direct connection with the database. (for normal Spring JDBC we dont have anotations and Id, column names should match with names in DB)


JPA(Java Persistence API)
-------------------------
Standard API for ORM
NO VENDOR LOCK-IN 

In springBoot, Hibernate is the default impl of JPA
SpringBoot automatically creates datasource and Entitymanager
---> Entity Manager is from JPA. Its is similar to Session

@Transactional is not needed in Spring Data JPA, it provides it by default


Data binding
-------------
It is the process of converting JSON data to and from java POJO's
@JsonInclude(Include.NON_NULL)  // to exclude any attribute whose value is null in JSON
@JsonIgnoreProperties(ignoreUnknown = true)  //to ignore additional changes in json that pojo class unware to avoid exceptions

jackson handles the data binding b/w JSON and Java POJO's internally in Spring Boot. In others we have to simply add Jackson-databind dependency

Rest over Http methods(CRUD operations)
----------------------
POST ---- CREATE
GET ---- READ
PUT ---- UPDATE
DELETE --- DELETE
HEAD ----  The HEAD method can be used to know, whether the resource exist on the server or not by analysing the status or headers of the response.

HEAD vs GET
The HEAD method does not return any responce body, while the GET method returns the content of the resource. The HEAD method is faster and more efficient, while the GET method is slower and more resource-intensive. 

Secure methods in springboot:
----------------------------
Spring Boot Starter Security does not activate method-level authorization by default.
You can activate it in your application by annotating any @Configuration class with @EnableMethodSecurity or adding <method-security> to any XML configuration file.
@EnableMethodSecurity -> Then, you are immediately able to annotate any Spring-managed class or method with @PreAuthorize, @PostAuthorize, @PreFilter, and @PostFilter to authorize method invocations, including the input parameters and return values.

1. Securing Methods with `@PreAuthorize` and `@PostAuthorize`
Spring Security provides annotations that enable you to secure methods with `@PreAuthorize` and `@PostAuthorize`, allow you to specify access control rules that determine if a method can be invoked or if its results can be returned.
`@PreAuthorize` -> Controlling Access Before Invocation
The `@PreAuthorize` annotation is used to specify that a method can only be invoked if the provided expression evaluates to `true` before the method is invoked.
Example: 
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Service;

@Service
public class OrderService {
    @PreAuthorize("hasRole('USER')")	//the `createOrder` method can only be invoked by users with the ‘USER’ role.
    public Order createOrder(Order order) {
        // Implementation
    }
}

`@PostAuthorize` -> Controlling Access After Invocation
The `@PostAuthorize` annotation ensures that a method can only be invoked if the provided expression evaluates to `true` after the method is invoked.
Example:
import org.springframework.security.access.prepost.PostAuthorize;
import org.springframework.stereotype.Service;

@Service
public class OrderService {	//the `viewOrder` method is only accessible if the customer who placed the order matches the authenticated user.
    @PostAuthorize("returnObject.customer.username == authentication.principal.username")	
    public Order viewOrder(long orderId) {
        // Implementation
    }
}

server side LB vs client side LB
--------------------------------
Server-side load-balancing: All backend server instances are registered with a central load balancer. A client requests this load balancer which then routes the request to one of the server instances using various algorithms like round-robin.
Client-side load-balancing: The load balancing decision resides with the client itself. The client can take the help of a naming server (eg. Netflix Eureka) to get the list of registered backend server instances, and then route the request to one of these backend instances.

1) If you are keeping the load balancer on the server side and giving the load balancing responsibility to the server, then it’s called Server-Side Load Balancing.
   If you are keeping the load balancer on the client side and giving the load balancing responsibility to the client, then it’s called Client-Side Load Balancing.	
2) The main disadvantage of Server-Side Load Balancing is the single point of failure.
   No more single point of failure in Client Side Load Balancer.	
3) Network latency rises in Server-Side Load Balancing.
   Less network latency as the client can directly call the backend servers.	
4) The cost is high to implement Server-Side Load Balancing in comparison to Client-Side Load Balancing.
   Cost Reduction(less) as there is no need for server-side load balancing.	

service discovery in springboot (Eureka)
----------------------------------------
Service discovery in microservices is the process of dynamically locating and identifying available services within a distributed system.
In a microservices environment, services are often deployed across multiple instances or containers, making it challenging for clients to locate and communicate with the appropriate service instances.
Service discovery solves this problem by providing mechanisms for service registration, discovery.
1. Service Registration
When a service instance is started or deployed, it registers itself with a service registry. This registration process includes providing metadata such as the service name, IP address, port number, and health status.
2. Service Discovery
Clients looking to interact with a particular service do not need to have prior knowledge of the service’s location. Instead, they query the service registry to dynamically discover the available instances of the desired service.

spring-cloud-starter-netflix-eureka-server -> add dependency
@EnableEurekaServer -> add in main class of springBoot app

#application.properties
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true


resilience4j package
--------------------
It helps with implementing resilient systems by managing fault tolerance for remote communications.

1) Circuit Breaker pattern helps us in preventing a cascade of failures when a remote service is down. After a number of failed attempts, we can consider that the service is unavailable/overloaded and eagerly reject all subsequent requests to
A CircuitBreaker can be in one of the three states:
	CLOSED – everything is fine, no short-circuiting involved
	OPEN – remote server is down, all requests to it are short-circuited
	HALF_OPEN – a configured amount of time since entering OPEN state has elapsed and CircuitBreaker allows requests to check if the remote service is back online
@CircuitBreaker(name = "companyBreaker", fallbackMethod = "companyBreakerFallback") -> add to respective method in service layer
		companyBreaker -> name that is configured in application.prop
		companyBreakerFallback -> method to impl fallout response

2) Retry pattern hepls us to automatically retry a failed call using the Retry API.
@Retry(name = "companyBreaker", fallbackMethod = "companyBreakerFallback")

3) Rate Limiter pattern allows limiting access to some service i.e, accepts only specific no. of requests to a particular service in given time.
@RateLimiter(name = "companyBreaker", fallbackMethod = "companyBreakerFallback")


zipkin
------
Spring Cloud Sleuth is a distributed tracing solution for Spring Cloud. It helps understand the latency issues in the microservice architecture by adding tracing information to the logs. While Sleuth helps to generate trace information, visualizing and storing it is a job for a tool like Zipkin.

Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures. Features include both the collection and lookup of this data. 
If you have a trace ID in a log file, you can jump directly to it. Otherwise, you can query based on attributes such as service, operation name, tags and duration. Some data will be summarized for you, such as the percentage of time spent in a service, and whether or not operations failed.

management.tracing.sampling.probability=1.0	-> in application.prop






===============SPRING MVC================
Spring MVC is a Model View, and Controller based web framework widely used to develop web applications. Spring MVC framework enables the separation of modules namely Model View, Controller, and seamlessly handles the application integration.
Model – A model can be an object or collection of objects which basically contains the data of the application.
View – A view is used for displaying the information to the user in a specific format. Spring supports various technologies like freemarker, velocity, and thymeleaf.
Controller – It contains the logical part of the application. @Controller annotation is used to mark that class as a controller.

Front Controller – Its responsible for managing the flow of the web application.
DispatcherServlet acts as the Front Controller for Spring-based web applications in spring MVC. Any request thats coming into our website front controller is going to stand in front and is going to accept all the requests and once the front-controller accepts that request then it is the job of the front-controller to make a decision that who is the right controller to handle that request.

In Spring, the /WEB-INF/web.xml file is the Web Application Deployment Descriptor of the application. This file is an XML document that defines everything about your application that a server needs to know (except the context path, which is assigned by the Application Deployer and Administrator when the application is deployed), servlets, and other components like filters or listeners, initialization parameters, container-managed security constraints, resources, welcome pages, etc. 
WEB-INF/web.xml
{servlet name}-servlet.xml

<servlet>
    <servlet-name>myDispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
 
<servlet-mapping>
    <!-- Provide a Servlet Name that you want to map -->
    <servlet-name>myDispatcherServlet</servlet-name>
    <!-- Provide a url pattern -->
    <url-pattern>/gfg.com/*</url-pattern>
</servlet-mapping>

So this does mean that the servlet “myDispatcherServlet” is going to handle all the requests starting from gfg.com/anything, that may be gfg.com/save or gfg.com/get etc. But it must start with gfg.com/

---or---
//class needs to implement WebApplicationInitializer
AnnotationConfigWebApplicationContext webApplicationContext  = new AnnotationConfigWebApplicationContext();
 
        // Registering the spring config class
        webApplicationContext.register(CalculatorAppConfig.class);
 
        // Creating a dispatcher servlet object
        DispatcherServlet dispatcherServlet = new DispatcherServlet(webApplicationContext);

---or---
//class needs to extend AbstractAnnotationConfigDispatcherServletInitializer, it has below methods.
public class CalculatorAppInitializer
    extends AbstractAnnotationConfigDispatcherServletInitializer {
 
    @Override 
    protected Class<?>[] getRootConfigClasses(){
        return null;
    }

//need to overrride this, to register the spring config class
    @Override protected Class<?>[] getServletConfigClasses(){
	Class aClass[] = { CalculatorAppConfig.class };
        return aClass;
    }

//need to overrride this, mapping for the dispatcher servlet
    @Override protected String[] getServletMappings(){
	String arr[] = { "/gfg.com/*" };
        return arr;
    }
}


methodname(HttpServletRequest req, )
-----------------------------------
String str=req.getParameter(" ");
int i= Integer.ParseInt(req.getParameter("name of var in jsp feilds"));
-or-
methodname(@RequestParam("name of var in jsp feilds") String str ) //reads parametrs from form data and bind it to str variable 


methodname(, Model theModel)  // used to pass data btw controller to views
----------------------------
theModel.addAttribute("attribute name", attribute value);
-or-
methodname(@ModelAtrribute("name of modelAtrribute in jsp form") Student thestudent) //it binds form data to obj
										     //it fetches all feilds of an obj

